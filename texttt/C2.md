

# Project Name: Ghost-Rig (`ghost-rig`)

Tagline: The Disposable Infrastructure Manager for Red Teams.

Philosophy: "Spin it up, use it, nuke it. No trace left behind."

---

### 1. Executive Summary

**Ghost-Rig** is a CLI-based TUI (Terminal User Interface) tool designed to abstract away the complexity of managing ephemeral Red Team infrastructure. Instead of manually writing Terraform files or clicking through AWS/DigitalOcean consoles, an operator selects a "Recipe" (e.g., _HTTP Redirector_, _Phishing Relay_) from a menu, and the tool handles the provisioning, hardening, and DNS configuration automatically.

Why build this?

Existing tools (Terraform, Ansible) are designed for permanence and stability. Red Teams need velocity and disposability. Ghost-Rig bridges this gap by treating infrastructure as disposable "cartridges."

---

### 2. High-Level Architecture

The system follows a **Controller-Agentless** model. Ghost-Rig runs locally on the operator's machine and drives cloud APIs.

Code snippet

```
graph TD
    User[Operator] -->|Interacts| TUI[Bubbletea TUI]
    TUI -->|Commands| Core[Core Logic / Controller]
    
    Core -->|Reads/Writes| DB[(Local SQLite State)]
    Core -->|Reads| Templates[Embedded Terraform Templates]
    
    Core -->|Executes| TF[Terraform / OpenTofu Wrapper]
    
    TF -->|API Calls| Cloud[AWS / DigitalOcean / Azure]
    
    Cloud -->|Returns IP/Keys| TF
    TF -->|Updates| DB
    DB -->|Status Update| TUI
```

---

### 3. Tech Stack Selection

We will use **Go (Golang)** for this project.

- **Reasoning:** Terraform is written in Go. The ecosystem for infrastructure automation is native to Go. It compiles to a single static binary, making it easy to share among team members without Python venv hell or Ruby gem dependencies.
    

**Core Libraries:**

- **UI/TUI:** `github.com/charmbracelet/bubbletea` (The gold standard for modern CLIs).
    
- **Styling:** `github.com/charmbracelet/lipgloss` (For that "cyberpunk" aesthetic).
    
- **Database:** `github.com/mattn/go-sqlite3` (Embedded SQL database).
    
- **Config Mgmt:** `github.com/spf13/viper` (For managing API keys/secrets).
    
- **IaC Engine:** We will **embed** the `terraform` binary or use `github.com/hashicorp/terraform-exec` to drive a local installation programmatically.
    

---

### 4. Core Features & Implementation Details

#### A. The "Cartridge" System (Templates)

Instead of hardcoding logic, Ghost-Rig uses a `templates/` directory embedded into the binary (using Go's `embed` package).

- **Structure:** Each "Cartridge" is a folder containing:
    
    - `main.tf`: The infrastructure definition.
        
    - `setup.sh`: The cloud-init user data (installs Nginx, Socat, etc.).
        
    - `meta.json`: Description, estimated cost/hour, required inputs (API key, domain).
        

**Example Cartridge: `redirector-http`**

- _Input:_ `Target_C2_IP`
    
- _Action:_ Spins up a $5 DigitalOcean droplet, installs Nginx, configures a reverse proxy to `Target_C2_IP`, opens port 80/443 only.
    

#### B. State Management (The "Ghost" Database)

We do not rely solely on `terraform.tfstate`. We maintain a shadow SQLite DB to track "Business Logic" metadata that Terraform ignores.

- **Table: `active_assets`**
    
    - `id` (UUID)
        
    - `alias` (e.g., "Phish-Campaign-Alpha")
        
    - `provider` (AWS/DO)
        
    - `ip_address`
        
    - `burn_rate_hourly`
        
    - `created_at`
        
    - `terraform_workspace_path` (Path to the temp dir where the TF state lives)
        

#### C. The "Kill Switch"

The most critical feature.

- **Command:** `ghost-rig nuke <id>` or `ghost-rig nuke --all`
    
- **Implementation:**
    
    1. Locate the Terraform workspace for that asset.
        
    2. Run `terraform destroy -auto-approve`.
        
    3. _Secure Delete:_ Overwrite the local `tfstate` file with zeros before deleting it to prevent forensic recovery of keys on the operator's laptop.
        
    4. Mark entry as `DESTROYED` in SQLite (keep the log for billing/reporting).
        

#### D. Cost Estimator

The TUI header will display a "Running Burn Rate."

- _Logic:_ Sum the `burn_rate_hourly` of all active rows in SQLite.
    
- _Visual:_ "ğŸ”¥ Current Burn: $0.14 / hour ($100.80 / month)"
    

---

### 5. UI/UX Design (The Bubbletea Layout)

The interface should feel like a cockpit.

**Main Dashboard View:**

Plaintext

```
  G H O S T - R I G  v1.0             [ğŸ”¥ Burn: $0.05/hr]
  -------------------------------------------------------
  ID     | TYPE         | IP            | AGE    | STATUS
  -------------------------------------------------------
  #A192  | Redirector   | 104.22.10.1   | 2h 10m | â— LIVE
  #B401  | Phish Relay  | 162.10.99.4   | 15m    | â—Œ PROVISIONING
  -------------------------------------------------------
  
  [N] New Asset   [K] Kill Asset   [S] Shell (SSH)   [Q] Quit
```

**Provisioning Wizard (Modal):**

1. **Select Provider:** `[AWS] [DigitalOcean] [Azure]`
    
2. **Select Cartridge:** `[HTTP Redirector] [SMTP Relay] [C2 Standard]`
    
3. **Config Inputs:** (Prompts user for specific vars like "Domain Name")
    

---

### 6. Development Roadmap

#### Phase 1: The Skeleton (MVP)

- **Goal:** Spin up 1 DigitalOcean droplet using a hardcoded template.
    
- **Tasks:**
    
    1. Set up Go project structure with Bubbletea.
        
    2. Implement `terraform-exec` to run `init` and `apply` on a test directory.
        
    3. Create the SQLite schema.
        
    4. Basic "List" and "Create" view.
        

#### Phase 2: The Library & Hardening

- **Goal:** Support AWS and secure the assets.
    
- **Tasks:**
    
    1. Add AWS provider support.
        
    2. Create `cloud-init` scripts that automatically enable UFW (Uncomplicated Firewall) and Fail2Ban on all assets.
        
    3. Implement the "Secure Nuke" feature.
        

#### Phase 3: Domain Fronting & DNS

- **Goal:** Automate the hardest partâ€”DNS.
    
- **Tasks:**
    
    1. Integrate Cloudflare API.
        
    2. When spinning up a redirector, automatically add the `A` record to Cloudflare and toggle "Proxy Mode" (orange cloud).
        
    3. Verify the domain is resolving before marking the asset as "LIVE".
        

---

### 7. Project Structure (File Tree)

Plaintext

```
ghost-rig/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ root.go          # Entry point (Cobra CLI)
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ tui/             # Bubbletea models and views
â”‚   â”‚   â”œâ”€â”€ dashboard.go
â”‚   â”‚   â””â”€â”€ wizard.go
â”‚   â”œâ”€â”€ core/            # Business logic
â”‚   â”‚   â”œâ”€â”€ terraform.go # Wrapper for TF execution
â”‚   â”‚   â””â”€â”€ db.go        # SQLite interactions
â”‚   â””â”€â”€ templates/       # The "Cartridges"
â”‚       â”œâ”€â”€ do-redirector/
â”‚       â””â”€â”€ aws-phish-relay/
â”œâ”€â”€ pkg/
â”‚   â””â”€â”€ utils/           # Helper functions (random names, IP checks)
â”œâ”€â”€ go.mod
â””â”€â”€ main.go
```

### 8. Immediate Next Step for You

If you want to start building this, **initialize the repo and the TUI skeleton first.**

Run this in your terminal:

Bash

```
mkdir ghost-rig && cd ghost-rig
go mod init github.com/yourusername/ghost-rig
go get github.com/charmbracelet/bubbletea
go get github.com/charmbracelet/lipgloss
go get github.com/spf13/cobra
```

Create a `main.go` that simply prints "Hello Ghost" using Bubbletea. Would you like me to provide the code for that **"Hello World" TUI skeleton** to get you started?